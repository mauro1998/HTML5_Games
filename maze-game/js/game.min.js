'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

(function () {
  var container = document.getElementById('container');
  var game = new Phaser.Game(960, 600, Phaser.AUTO, container, null, false, true);

  var PlayState = function (game) {
    var assets = [{ type: 'image', name: 'background', src: 'images/background.png' }, { type: 'image', name: 'ground', src: 'images/ground.png' }, { type: 'image', name: 'grass:8x1', src: 'images/grass_8x1.png' }, { type: 'image', name: 'grass:6x1', src: 'images/grass_6x1.png' }, { type: 'image', name: 'grass:4x1', src: 'images/grass_4x1.png' }, { type: 'image', name: 'grass:2x1', src: 'images/grass_2x1.png' }, { type: 'image', name: 'grass:1x1', src: 'images/grass_1x1.png' }, { type: 'image', name: 'key', src: 'images/key.png' }, { type: 'image', name: 'hero_stopped', src: 'images/hero_stopped.png' }, { type: 'image', name: 'invisible_wall', src: 'images/invisible_wall.png' }, { type: 'spritesheet', name: 'decor', src: 'images/decor.png', width: 42, height: 42 }, { type: 'spritesheet', name: 'coin', src: 'images/coin_animated.png', width: 22, height: 22 }, { type: 'spritesheet', name: 'door', src: 'images/door.png', width: 42, height: 66 }, { type: 'spritesheet', name: 'spider', src: 'images/spider.png', width: 42, height: 32 }, { type: 'spritesheet', name: 'hero', src: 'images/hero.png', width: 36, height: 42 }, { type: 'audio', name: 'sfx:jump', src: 'audio/jump.wav' }, { type: 'audio', name: 'sfx:coin', src: 'audio/coin.wav' }, { type: 'audio', name: 'sfx:key', src: 'audio/key.wav' }, { type: 'audio', name: 'sfx:stomp', src: 'audio/stomp.wav' }, { type: 'audio', name: 'music:background', src: 'audio/bgm.mp3', volume: 4, loop: true }];

    var obj = {};
    var sounds = void 0;
    var keys = void 0;
    var hasKey = false;

    var Character = function (_Phaser$Sprite) {
      _inherits(Character, _Phaser$Sprite);

      function Character(x, y, name) {
        _classCallCheck(this, Character);

        var _this = _possibleConstructorReturn(this, (Character.__proto__ || Object.getPrototypeOf(Character)).call(this, game, x, y, name));

        _this._initialX = x;
        _this._initialY = y;
        _this.anchor.set(0.5);
        game.stage.addChild(_this);
        game.physics.enable(_this, Phaser.Physics.ARCADE);
        _this.body.collideWorldBounds = true;
        return _this;
      }

      _createClass(Character, [{
        key: 'move',
        value: function move() {
          var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

          this.body.velocity.x = this.MOVE_SPEED * direction;
          if (this.body.velocity.x < 0) this.scale.x = -1;else this.scale.x = 1;
        }
      }]);

      return Character;
    }(Phaser.Sprite);

    var Hero = function (_Character) {
      _inherits(Hero, _Character);

      function Hero(x, y) {
        _classCallCheck(this, Hero);

        var _this2 = _possibleConstructorReturn(this, (Hero.__proto__ || Object.getPrototypeOf(Hero)).call(this, x, y, 'hero', 0));

        _this2.MOVE_SPEED = 200;
        _this2.JUMP_SPEED = 350;
        _this2.JUMP_HOLD = 300;
        _this2.BOUNCE_SPEED = 200;
        _this2.animations.add('stop', [0]);
        _this2.animations.add('run', [1, 2], 8, true);
        _this2.animations.add('jump', [3]);
        _this2.animations.add('fall', [4]);
        _this2.animations.add('die', [5, 6, 5, 6], 8);
        window.hero = _this2;
        return _this2;
      }

      _createClass(Hero, [{
        key: 'getAnimName',
        value: function getAnimName() {
          var name = 'stop';
          if (!this.alive) name = 'die';else if (this._isFrozen) name = 'stop';else if (this.body.velocity.y < 0) name = 'jump';else if (this.body.velocity.y >= 0 && !this.body.touching.down) name = 'fall';else if (this.body.velocity.x !== 0 && this.body.touching.down) name = 'run';
          return name;
        }
      }, {
        key: 'update',
        value: function update() {
          this._name = this.getAnimName();
          if (this._name !== this.animations.name) {
            this.animations.play(this._name);
          }

          if (this._stillOnAir && this.body.velocity.y === 0 && this.body.touching.down) {
            this._stillOnAir = false;
          }
        }
      }, {
        key: 'jump',
        value: function jump() {
          var isOnFloor = this.body.velocity.y === 0 && this.body.touching.down;
          var isOnAirOnce = this.body.velocity.y > 0 && !this.body.touching.down && !this.isBoosting && !this._stillOnAir;

          var canJump = this.alive && !this._isFrozen && (isOnFloor || isOnAirOnce || this.isBoosting);

          if (isOnFloor || isOnAirOnce) sounds.jump.play();

          if (canJump) {
            this.body.velocity.y = -this.JUMP_SPEED;
            this._stillOnAir = true;
            this.isBoosting = !this.body.touching.up && !this.body.blocked.up && this.body.velocity.y <= 0;
          }
        }
      }, {
        key: 'bounce',
        value: function bounce() {
          this.body.velocity.y = -this.BOUNCE_SPEED;
        }
      }, {
        key: 'freeze',
        value: function freeze() {
          this.body.enable = false;
          this._isFrozen = true;
        }
      }, {
        key: 'die',
        value: function die(callback) {
          var _this3 = this;

          this.freeze();
          this.alive = false;
          this.animations.play('die').onComplete.addOnce(function () {
            _this3.kill();
            callback();
          });
        }
      }]);

      return Hero;
    }(Character);

    var Spider = function (_Character2) {
      _inherits(Spider, _Character2);

      function Spider(x, y) {
        _classCallCheck(this, Spider);

        var _this4 = _possibleConstructorReturn(this, (Spider.__proto__ || Object.getPrototypeOf(Spider)).call(this, x, y, 'spider'));

        _this4.MOVE_SPEED = game.rnd.between(100, 130);
        _this4.animations.add('crawl', [4, 3, 2], 8, true);
        _this4.animations.add('die', [4, 0, 4, 0, 4, 0, 1, 1, 1, 1, 1, 1], 8, false);
        _this4.animations.play('crawl');
        _this4.move(1);
        return _this4;
      }

      _createClass(Spider, [{
        key: 'update',
        value: function update() {
          if (this.body.touching.left || this.body.blocked.left) this.move(1);else if (this.body.touching.right || this.body.blocked.right) this.move(-1);
        }
      }, {
        key: 'die',
        value: function die() {
          var _this5 = this;

          this.body.enable = false;
          this.animations.currentAnim.stop();
          this.animations.play('die').onComplete.addOnce(function () {
            return _this5.kill();
          });
        }
      }]);

      return Spider;
    }(Character);

    function init() {
      game.renderer.renderSession.roundPixels = true;
      game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
      game.scale.pageAlignVertically = true;
      game.scale.pageAlignHorizontally = true;
      game.stage.backgroundColor = '#FFFFFF';
      game.scale.refresh();

      keys = game.input.keyboard.addKeys({
        LEFT: Phaser.Keyboard.A,
        RIGHT: Phaser.Keyboard.D,
        UP: Phaser.Keyboard.SPACEBAR
      });
    }

    function preload() {
      game.load.json('level:1', 'data/level01.json');
      assets.forEach(function (asset) {
        var type = asset.type,
            name = asset.name,
            src = asset.src,
            width = asset.width,
            height = asset.height;

        game.load[type](name, src, width, height);
      });
    }

    function createPlatforms(platforms) {
      obj.platforms = game.add.group();
      obj.enemyWalls = game.add.group();
      platforms.forEach(function (platformData) {
        var x = platformData.x,
            y = platformData.y,
            image = platformData.image;

        var platform = game.add.sprite(x, y, image);
        game.physics.enable(platform, Phaser.Physics.ARCADE);
        platform.body.immovable = true;
        platform.body.allowGravity = false;
        obj.platforms.add(platform);
        var rightWall = createEnemyWall(platform.x + platform.width, platform.y);
        var leftWall = createEnemyWall(platform.x - rightWall.width, platform.y);
        obj.enemyWalls.add(rightWall);
        obj.enemyWalls.add(leftWall);
      });
    }

    function createEnemyWall(x, y) {
      var wall = game.add.sprite(x, y, 'invisible_wall');
      wall.anchor.set(0, 1);
      game.physics.enable(wall);
      wall.body.immovable = true;
      wall.body.allowGravity = false;
      wall.visible = false;
      return wall;
    }

    function createDecoration(decoration) {
      decoration.forEach(function (decor) {
        var x = decor.x,
            y = decor.y,
            frame = decor.frame;

        game.add.sprite(x, y, 'decor', frame);
      });
    }

    function createCoins(coinsPos) {
      obj.coins = game.add.group();
      coinsPos.forEach(function (pos) {
        var x = pos.x,
            y = pos.y;

        var coin = game.add.sprite(x, y, 'coin', 0);
        coin.anchor.set(0.5);
        coin.animations.add('rotate', [0, 1, 2, 1]);
        coin.animations.play('rotate', 8, true);
        game.physics.enable(coin, Phaser.Physics.ARCADE);
        coin.body.allowGravity = false;
        obj.coins.add(coin);
      });
    }

    function createDoor(doorPos) {
      var x = doorPos.x,
          y = doorPos.y;

      obj.door = game.add.sprite(x, y, 'door', 0);
      obj.door.anchor.set(0, 1);
      obj.door.animations.add('open');
      game.physics.enable(obj.door, Phaser.Physics.ARCADE);
      obj.door.body.allowGravity = false;
    }

    function createKey(keyPos) {
      var x = keyPos.x,
          y = keyPos.y;

      obj.key = game.add.sprite(x, y, 'key', 0);
      obj.key.anchor.set(0.5);
      game.physics.enable(obj.key, Phaser.Physics.ARCADE);
      obj.key.body.allowGravity = false;
    }

    function createSpiders(spiders) {
      obj.spiders = game.add.group();
      spiders.forEach(function (spiderPos) {
        var x = spiderPos.x,
            y = spiderPos.y;

        var spider = new Spider(x, y);
        obj.spiders.add(spider);
      });
    }

    function createHero(pos) {
      var x = pos.x,
          y = pos.y;

      obj.hero = new Hero(400, y);
    }

    function loadLevel(data) {
      var GRAVITY = 1200;
      game.physics.arcade.gravity.y = GRAVITY;
      createPlatforms(data.platforms);
      createDecoration(data.decoration);
      createCoins(data.coins);
      createDoor(data.door);
      createKey(data.key);
      createSpiders(data.spiders);
      createHero(data.hero);
    }

    function createSounds() {
      sounds = assets.filter(function (_ref) {
        var type = _ref.type;
        return type === 'audio';
      }).reduce(function (wrap, asset) {
        var name = asset.name,
            volume = asset.volume,
            loop = asset.loop;

        wrap[name.split(':').pop()] = game.add.audio(name, volume, loop);
        return wrap;
      }, {});
    }

    function create() {
      game.physics.startSystem(Phaser.Physics.ARCADE);
      game.add.sprite(0, 0, 'background');
      loadLevel(game.cache.getJSON('level:1'));
      createSounds();
      game.camera.flash(0xFFFFFF, 500);
      sounds.background.play();
    }

    function handleInput() {
      if (keys.LEFT.isDown) {
        obj.hero.move(-1);
      } else if (keys.RIGHT.isDown) {
        obj.hero.move(1);
      } else {
        obj.hero.move(0);
      }

      if (keys.UP.downDuration(obj.hero.JUMP_HOLD)) {
        obj.hero.jump();
      } else {
        obj.hero.isBoosting = false;
      }
    }

    function onHeroOverlapCoin(hero, coin) {
      coin.kill();
      sounds.coin.play();
    }

    function onHeroOverlapsEnemy(hero, spider) {
      var enemyStomped = hero.body.velocity.y > 0 && hero.body.touching.down;
      sounds.stomp.play();

      if (enemyStomped) {
        hero.bounce();
        spider.die();
      } else {
        hero.die(function () {
          return restartGame();
        });
      }
    }

    function restartGame() {
      game.camera.fade(0xFFFFFF, 500);
      sounds.background.stop();
      game.camera.onFadeComplete.addOnce(function () {
        game.state.restart();
      });
    }

    function onHeroOverlapsKey(hero, key) {
      hasKey = true;
      key.kill();
      sounds.key.play();
    }

    function onHeroOverlapsDoor(hero, door) {
      hero.body.moves = false;
      door.animations.play('open');
    }

    function handleCollisions() {
      game.physics.arcade.collide(obj.hero, obj.platforms);
      game.physics.arcade.collide(obj.spiders, obj.platforms);
      game.physics.arcade.collide(obj.spiders, obj.enemyWalls);
      game.physics.arcade.overlap(obj.hero, obj.spiders, onHeroOverlapsEnemy);
      game.physics.arcade.overlap(obj.hero, obj.coins, onHeroOverlapCoin);
      game.physics.arcade.overlap(obj.hero, obj.key, onHeroOverlapsKey);
      game.physics.arcade.overlap(obj.hero, obj.door, onHeroOverlapsDoor);
    }

    function update() {
      handleCollisions();
      handleInput();
    }

    return { preload: preload, create: create, update: update, init: init };
  }(game);

  game.state.add('Play', PlayState);
  game.state.start('Play');
})();
